---
tags:
  - csharp
date: 2025-09-23
---
[Арифметическое переполнение | checked unchecked c# | C# ОТ НОВИЧКА К ПРОФЕССИОНАЛУ | # 51](https://www.youtube.com/watch?v=bRwsKSLAgYw&list=PLQOaTSbfxUtD6kMmAYc8Fooqya3pjLs1N&index=71)

### Пример ядерного Ганди:

```csharp
byte agression = 1;

byte democracyModifier = 2;

agression = (byte)(agression - democracyModifier);//сужающее приведение данных

Console.WriteLine(agression); //255(максимум для байта)
```

- **Тип `byte` в C#**  
    Это целое число от 0 до 255. Ниже нуля он падать не умеет. Если ты вычитать что-то большее, чем у него есть — происходит арифметическое переполнение.

- **Что именно происходит у тебя**- `agression` = 1

- `democracyModifier` = 2

- 1 - 2 = -1  
   Но `byte` не знает, что такое -1. В двоичном представлении -1 превращается в 255, потому что значение "заворачивается" по кругу.


### Переполнение по верхней и нижней границе.

```csharp
int a = int.MaxValue;
a = a + 1; //переполнение через верхнюю границу
Console.WriteLine(a); //выведет -2147483648

int b = int.MinValue;
b = b - 1; //переполнение через нижнюю границу
Console.WriteLine(b);// выведет 2147483647
```

- `int` хранит числа от -2147483648 до 2147483647.

- При выходе за диапазон значения "зацикливаются" (unchecked по умолчанию).

- так себя ведут все целочисленные типы данных

### Проверка переполнения 

>Ее можно включить на уровне всего проекта но это замедлит код и не всегда удобно

1) Нажать по проекту пкм и выбрать свойства
![[Pasted image 20250923134305.png]]
2) Сборка -> дополнительно
![[Pasted image 20250923134422.png]]

3) Поставить галочку на "проверять арифметическое переполнение"
![[Pasted image 20250923134526.png]]

>При включенной проверке и переполнении, компилятор выдаст исключение.

### #ключевое_слово  checked

>В случае переполнения, и использования ключевого слова `checked` компилятор тоже выдаст исключение

> Способ применения 1:
```csharp
checked
{
    int a = int.MaxValue;
    a = a + 1;
    Console.WriteLine(a);

    int b = int.MinValue;
    b = b - 1;
    Console.WriteLine(b);
}
```
>Способ применения 2:
```csharp
    int a = int.MaxValue;
    a = checked(a + 1);
    Console.WriteLine(a);

    int b = int.MinValue;
    b = checked(b - 1);
    Console.WriteLine(b);
```

### Ключевое слово unchecked

>Применяется когда на уровне всего проекта включена проверка переполнения.

>С его помощью можно выключить эту проверку

### бонус: обработка исключений с помощью `try` `catch`

```csharp
byte agression = 1;
byte democracyModifier = 2;

try
{
    agression = (byte)(agression - democracyModifier);
    //сужающее приведение данных

    Console.WriteLine(agression); 
}
catch (OverflowException) 
{
    Console.WriteLine("ошибка!!");
}
```

>Программа не упадет, а выведет сообщение об ошибке

### Дробные типы данных.

>У дробных типов данных не существует переполнения.

```csharp
    double a = 1.0 / 0.0;
    Console.WriteLine(double.IsInfinity(a)); // output = true

     double b = 0.0 / 0.0;
    Console.WriteLine(double.IsNaN(b)); // output = true

    double c = double.MaxValue + double.MaxValue;
    Console.WriteLine(double.IsInfinity(c)); // output = true
```

- Деление на ноль даёт `Infinity`.

- Операции, не имеющие смысла (например, 0/0), возвращают `NaN` (Not a Number).

- Слишком большие результаты вычислений тоже уходят в `Infinity`.

Так язык избегает исключений при каждом переполнении дробных чисел и даёт программисту возможность самому проверять значения через `double.IsInfinity()` и `double.IsNaN()`.

### Переполнение у `decimal`

>Переполнение у `decimal` всегда вызывает ошибку. Т.к. этот точный тип данных используется для финансовых расчетов.
```csharp
decimal x = decimal.MaxValue;

unchecked
{
    // Здесь всё равно произойдёт ошибка,
    // потому что decimal НЕ поддерживает "бесконечность" и "NaN"
    // как double или float.
    // Любое переполнение сразу выбрасывает OverflowException.
    x = x + 1;
}
```