---
tags:
  - csharp
  - ключевое_слово
date: 2025-08-14
---
[КЛЮЧЕВОЕ СЛОВО OUT C# | РАЗНИЦА между REF и OUT C# | C# ОТ НОВИЧКА К ПРОФЕССИОНАЛУ | # 44](https://youtu.be/R9i0XFWkFps?si=qGf9I5vpgE-3oTPg)
## Ключевое слово OUT

- **Оба передают аргумент по ссылке.**  
    То есть метод работает не с копией переменной, а с самой переменной, которая была передана. Любое изменение внутри метода отражается снаружи.
    
- **Оба позволяют методу изменить значение переменной.**  
    Если внутри метода присвоить новое значение, оно будет доступно после выхода из метода.
    
- **Синтаксис вызова похожий.**  
    Вызов метода требует ключевого слова `ref` или `out` перед переменной:

```csharp
        static void Foo(ref int x) 
        {
            x ++;
            Console.WriteLine(x);
        }  
        static void Main(string[] args)
        {
            int a = 1;
            Foo(ref a);
        }
```

## Отличия `REF` и `OUT`

**Инициализация перед вызовом**

- `ref` → переменная должна быть **уже инициализирована** (`int a = 1;`)

- `out` → переменную можно **не инициализировать**, метод присвоит значение сам (`int a;`)

- **Присвоение внутри метода**

- `ref` → метод **может не присваивать новое значение**, просто менять или использовать старое.
- `out` → метод **обязан присвоить значение**, иначе компилятор выдаст ошибку.

**Смысл использования**

- `ref` → метод **работает с существующим значением**, может его менять.

- `out` → метод **возвращает значение через параметр**, как дополнительный выход метода.

### Инициализация перед вызовом

**С `ref` переменная должна быть уже инициализирована**:

```Csharp
static void Foo(ref int x)
{
    x++;
    Console.WriteLine(x);
}

static void Main()
{
    int a = 1;       // <- важно: a уже имеет значение
    Foo(ref a);       // работает
}
```

Если убрать инициализацию:

```csharp
int a;              // не инициализирована
Foo(ref a);          // Ошибка компиляции!
```

Компилятор скажет: `Use of unassigned local variable 'a'` — потому что `ref` работает **с существующим значением**.

### С `out` можно не инициализировать переменную:

```csharp
static void Foo(out int x)
{
    x = 10;          // обязательно присвоить
    Console.WriteLine(x);
}

static void Main()
{
    int a;           // можно не инициализировать
    Foo(out a);       // работает
    Console.WriteLine(a); // 10
}

```

### Смысл использования

**ref** → «используем и меняем существующее значение»:

```csharp
int a = 5;
Foo(ref a); // a становится 6
```

**out** → «метод возвращает значение через параметр»:

```csharp
int a;           // даже без значения
Foo(out a);      // a теперь равно 10
```

То есть `ref` нужен, когда у тебя есть уже какое-то значение, которое нужно изменить.  
`out` нужен, когда переменная ещё не имеет значения, и ты хочешь, чтобы метод **«записал» результат туда**.

Кроме того, с `out` переменную можно oбъявить прямо в методе:

```csharp
Foo(out int a);
```

### Пример применения OUT

```csharp
string str = Console.ReadLine();

int.TryParse(str, out int result);//Если не сможет, присвоит result = 0;

Console.WriteLine(result);
```

##### Итог: `out` в C# **жёстко гарантирует**, что переменная получит значение **в любом случае**, иначе код даже не скомпилируется.