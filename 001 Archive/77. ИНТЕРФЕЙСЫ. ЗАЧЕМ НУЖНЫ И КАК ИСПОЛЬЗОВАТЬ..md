---
tags:
  - csharp
  - ООП
  - полиморфизм
  - интерфейсы
date: 2026-02-14
---
[Интерфейсы в C# зачем нужны и как используются | C# ОТ НОВИЧКА К ПРОФЕССИОНАЛУ | # 77](https://www.youtube.com/watch?v=8eZy5xiildM&list=PLQOaTSbfxUtD6kMmAYc8Fooqya3pjLs1N&index=98)
# Что такое интерфейсы?

Интерфейсы можно сравнить с абстрактным классом, у которого абстрактные только методы.

# Для чего нужны интерфейсы?

>Задача интерфейса - определить поведение, которое используется в конкретном классе.

Пример из прошлого урока [[76.  АБСТРАКТНЫЕ КЛАССЫ И МЕТОДЫ]] :

У нас есть класс `Weapon`, где определено поведение метода `Fire()`

```csharp
    abstract class Weapon
    {
        public abstract int Damage { get; }//ТУТ
        public abstract void Fire();
        
        public void GetInfo()//ТУТ
        {
            Console.WriteLine($"{GetType().Name}\tDamage: {Damage}");
        }
    }
```

Но сама реализация поведения определена в классах наследниках:

```csharp
    class Cannon : Weapon
    {
        public override void Fire()
        {
            Console.WriteLine("Дыдыщь");
        }
    }
    class LaserGun : Weapon
    {
        public override void Fire()
        {
            Console.WriteLine("Пиу");
        }
    }
    class Gun : Weapon
    {
        public override void Fire()
        {
            Console.WriteLine("Бум");
        }
    }
```

Но в отличие от абстрактного класса, задача интерфейса заключается только в определении поведения, без каких то деталей. 

Таким образом интерфейсы определяют, что должен делать класс, но не как.

# Реализация Интерфейса

Синтаксис:

```csharp
public interface имя
{
	возвращаемый_тип имя_метода(список_параметров)
	возвращаемый_тип имя_метода(список_параметров)
	возвращаемый_тип имя_метода(список_параметров)
}
```

По существу методы внутри интерфейса - абстрактные методы.

>Переменных там быть не может, потому что интерфейсы определяют поведение.

Каждому классу представляется полная свобода для определения реализации, то есть один и тот же интерфейс может быть реализован в разных классах по разному.

Тем не менее в каждом из них должен поддерживаться одинаковый набор методов.

>Главный принцип полиморфизма: один интерфейс, множество методов.

В C# есть соглашение о нейминге, по которому перед именем интерфейса ставится префикс `I`чтобы не перепутать с классами `public interface ISeries`.

> По умолчанию члены интерфейса и сам интерфейс имеют модификатор `public`

>Еще интерфейсы могут содержать свойства (т.к. свойства это методы маскирующиеся под поля)

[[62. СВОЙСТВА GET SET. КЛЮЧЕВОЕ СЛОВО VALUE. АВТОМАТИЧЕСКИЕ СВОЙСТВА]]
# Пример

```csharp
    interface IDataProvider
    {
        string GetData();
    }
    interface IDataProcessor
    {
        void ProcessData(IDataProvider dataProvider);
    }
```

2 интерфейса, 1 из которых получает какие-то данные (строку), а другой что-то делает с этими данными, принимая ссылку на первый класс.

```csharp
    class ConsoleDataProcessor : IDataProcessor
    {
        public void ProcessData(IDataProvider dataProvider)
        {
            Console.WriteLine(dataProvider.GetData());
        }
    }
```

> Тут используется синтаксис #наследование 

Класс, реализующий `IDataProcessor`, т.е. интерфейс, который принимает ссылку на другой интерфейс (`IDataProvider`) и вызывает у него метод `string GetData();` и выводит строку на консоль.

`string GetData();` там уже существует, т.к. мы его определили в контракте, когда создавали 1й интерфейс (`IDataProvider`)

```csharp
        static void Main(string[] args)
        {
            IDataProcessor processor = new ConsoleDataProcessor();
        }
```

 Мы можем присвоить в объект типа  `IDataProcessor` класс `ConsoleDataProcessor()`, который этот интерфейс реализует.

>Раз интерфейс реализован в классе, то ссылка на интерфейс может хранить объект класса.

Добавим разные реализации:

```csharp
    class DbDataProvider : IDataProvider
    {
        public string GetData()
        {
            return "Db Data";
        }
    }
    class FileDataProvider : IDataProvider
    {
        public string GetData()
        {
            return "File Data";
        }
    }
    class ApiDataProvider : IDataProvider
    {
        public string GetData()
        {
            return "API Data";
        }
    }
```

```csharp
        static void Main(string[] args)
        {
            IDataProcessor processor = new ConsoleDataProcessor();
            processor.ProcessData(new DbDataProvider());
            processor.ProcessData(new ApiDataProvider());
            processor.ProcessData(new FileDataProvider());
        }
```

Теперь наш `ConsoleDataProcessor()` может работать с любым из классов.

Мы вызываем метод `ProcessData`.

В качестве параметра передаем объект `IDataProvider`, который тут же и создаем.

Потом мы попадаем в `IDataProcessor`, который принимает ссылку на `IDataProvider` и выводит на консоль результат  метода`string GetData();`

А наши классы все реализуют `IDataProvider`, и у них у всех есть метод `string GetData();`

