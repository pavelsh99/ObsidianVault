---
tags:
  - csharp
  - ООП
  - полиморфизм
  - наследование
date: 2025-12-04
---
[Наследование в C# | Что такое наследование в ооп | C# ОТ НОВИЧКА К ПРОФЕССИОНАЛУ | # 71](https://www.youtube.com/watch?v=9JaiDu6DJ-o&list=PLQOaTSbfxUtD6kMmAYc8Fooqya3pjLs1N&index=91)
# Для чего нужно наследование

> Наследование - это инструмент, позволяющий избежать ненужного дублирования кода.

>Наследование это инструмент в ООП, который позволяет реализовать полиморфизм.

# Почему дублирование кода - это плохо?

> Потому что есть рабочий код, а новый нужно написать и протестировать.

>Если есть 2 класса, с одним функционалом, то если исправить баг в одном, второй это не починит.

>Чем больше дублей, тем больше таких изменений нужно делать

>Наследование позволяет применить изменения к старому коду без модификаций.

# Суть и Синтаксис

есть класс `Person`

```csharp
    class Person
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }

        public void PrintName()
        {
            Console.WriteLine($"Меня зовут: {FirstName}");
        }
    }
```

Допустим, нам нужно написать класс в котором есть схожий функционал.

```csharp
class Student
{
	
}
```

Поля `Person` подойдут и классу `Student`

> Чтобы унаследоваться нужно поставить двоеточие и указать класс от которого мы хотим унаследоваться.

```csharp
    class Student : Person
    {
		
    }
```

Создадим объект класса `Student`.

```csharp
Student Student = new Student();
```

![[Pasted image 20251204090431.png]]

У объекта класса `Student` унаследовались все методы и поля класса `Person`.

Попробуем вызвать метод `Print` у студента

```csharp
Student.PrintName();
```

> В `debug` видно, что мы попадаем в метод `PrintName` из класса `Person`

![[Pasted image 20251204091335.png]]

> По терминологии `Student` является **==наследником==** класса `Person`, а класс `Person` является **==родительским==** или **==базовым для класса==**  `Student`.

## Другой функционал наследования:

Мы можем реализовать другой функционал или поведение у `Student`

Добавим метод `Learn` классу `Student`

```csharp
    class Person
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }

        public void PrintName()
        {
            Console.WriteLine($"Меня зовут: {FirstName}");
        }
    }

    class Student : Person
    {
        public void Learn()
        {
            Console.WriteLine("Я учусь!");
        }
    }
```

>Теперь студент умеет учиться, в то время как `Person` этого не умел

## Наследник, который является родительским(Базовым) классом:

>Мы можем создать объект класса `Person`, но присвоить туда объект класса `Student`:

```csharp
            Person Student = new Student 
            { 
	            LastName = "Паша",
	            FirstName = "Шарапов" 
            };
             
            Student.PrintName();
```

> Но что если мы попытаемся вызвать метод `Learn()`, который есть только у класса `Student`?

> Мы получим ошибку, что `Person` не содержит метода `Learn()`, хоть мы и присвоили объекту  класса`Person` класс `Student`
![[Pasted image 20251204093151.png]]

> Дело в том, что метод `Learn()` это функционал исключительно наследника

## Вывод:

>==Когда мы присваиваем объекту базового класса тип данных наследника, то исходный объект будет иметь только функционал родителя ==

## Когда это нужно?

Допустим у нас нет класса `Student`

```csharp
    class Person
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }

        public void PrintName()
        {
            Console.WriteLine($"Меня зовут: {FirstName}");
        }
    }
```

Но наша программа как-то использует объекты класса `Person`

(у нас это метод, который принимает объект `Person` и выводит полное имя)

```csharp
        static void Main(string[] args)
        {
            Person person = new Person 
            {
	            FirstName = "Паша",
	            LastName = "Шарапов" 
            };

            void PrintFullName(Person person1)
            {
                Console.WriteLine($"Имя: {person1.FirstName}\tФамилия: {person1.LastName} ");
            }
            PrintFullName(person);//тут
        }
```

Но допустим у нас появился метод `Student` со своим функционалом:

```csharp
    class Student : Person
    {
        public void Learn()
        {
            Console.WriteLine("Я учусь!");
        }
    }
```

Но мы хотим, чтобы наш старый код работал с новыми типами данных

Метод `PrintFullName` сможет использовать объект типа `Student`

> Но он сможет использовать только те части класса `Student`, которые были реализованы в его предке, классе `Person`

==В таких ситуациях удобно использовать наследника, который является родительским классом==

# Строим диаграмму наследования (необязательно)

> У нас есть различные классы, которые от друг друга наследуют:
> ![[Pasted image 20251204102025.png]]

`Person:
	`Student`
	`Emploee:`
		`Guard`
		`Teacher`

> чтобы разобраться со сложной структурой наследования, может помочь диаграмма классов.

чтобы ее построить добавляем диаграмму классов:
![[Pasted image 20251204102446.png]]

## Как ее использовать:

1) Переходим на нее
![[Pasted image 20251204102630.png]]

2) Перетаскиваем на нее все нужные классы
![[Pasted image 20251204102716.png]]

3) Результат:
![[Pasted image 20251204103031.png]]

# Множественное наследование.

>В C# у классов нет множественного наследования, но #интерфейсы имеют такой функционал.

![[Pasted image 20251204103427.png]]

