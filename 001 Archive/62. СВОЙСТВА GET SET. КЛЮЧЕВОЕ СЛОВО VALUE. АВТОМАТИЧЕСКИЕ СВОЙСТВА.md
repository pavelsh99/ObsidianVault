---
tags:
  - csharp
  - инкапсуляция
date: 2025-10-29
---
[C# свойства get set | ключевое слово value | автоматические свойства c# | ООП C# Урок | # 62]()
# Геттеры и Сеттеры

```csharp
    class Point
    {
        private int x;
        public void SetX(int x)
        {
            this.x = x;
        }
        public int GetX(int X)     
        {
            return x; 
        }
    }
```

> Г и С нужны чтобы реализовывать и  не нарушать инкапсуляцию.
>
> С их помощью мы можем изменять `private` поле `x`. 
>
>Чтобы всё работало правильно мы инкапсулируем поле `x` и используем
> 	-Геттер(возвращает значение поля)
> 	-Сеттер(присваивает значение поля)


Например у нас может быть ситуация когда для логики программы нужно, чтобы `x` был от `1` до `5`. 
```csharp
        public void SetX(int x)
        {
            if (x < 1)
            {
                this.x = x;
                return;
            }
            if (x > 5)
            {
                this.x = 5;
                return;
            }
                this.x = x;
        }
```

> Теперь даже если мы попытаемся присвоить значение больше `5` , выполнится проверка и присвоится максимальное значение значение `5`.

> Благодаря `сеттеру` и инкапсуляции мы не можем получить доступ к полю `x`.


# Можно использовать геттеры и сеттеры, но для этой функции есть **СВОЙСТВА (PROPERTIES)**

>При использовании свойств не нужно вызывать методы, всё будет выглядеть будто мы работаем с полем `x`.

> Чтобы вызвать поля используем снипет `propful`

![[Pasted image 20251029133907.png]]

> Переделаем свойства под себя:

```csharp
 private int у;

 public int Y
 {
     get
     { 
         return у; 
     }
     set 
     {
         у = value; 
     }
 }
```

>Теперь на уровне объекта класса мы можем обращаться к свойству "как к полю"
>![[Pasted image 20251029134644.png]]

```csharp
        static void Main(string[] args)
        {
            Point point = new Point();
            point.Y = 5;
            int y = point.Y;
        }
```

> `get` и `set` это аксессоры

> когда мы обращаемся к полю`.Y` мы попадаем в `get` а когда мы присваиваем полю `.Y` попадаем в `set`

# Ключевое слово `value`

```csharp
     set 
     {
         у = value; 
     }
```

> ключевое слово `value` по сути то же самое что и значение, которое мы присваиваем в поле. `point.Y = 10;`

> Для `value` не нужно указывать тип данных. Он будет таким, каким мы указали его в свойстве.

```csharp 
private int у;

public int Y // ТУТ
 {
     get
     { 
         return у; 
     }
     set 
     {
         у = value; // Value int
     }
 
```

> Со свойствами не будет конфликта имен и `this` не нужен. [[61. КЛЮЧЕВОЕ СЛОВО THIS. THIS В КОНСТРУКТОРЕ]]

# Модифицируем свойства.

> Выполним, то что делали с геттерами и сеттерами при помощи свойств.

```csharp
        public int Y
        {
            get
            { 
                return у; 
            }
            set // Тут
            {
                if (value < 1)
                {
                    value = 1;
                    return;
                }
                if (value > 5)
                {
                    value = 5;
                    return;
                }

                у = value; 
```

# Частичная реализация свойств

> Возможно нам не нужно давать возможность пользователю получать переменную.
> .
> В таком случае мы можем частично реализовать свойства, уберем `get`

```csharp
        public int Y
        {

            set 
            {
                if (value < 1)
                {
                    value = 1;
                    return;
                }
                if (value > 5)
                {
                    value = 5;
                    return;
                }

                у = value;
        } 
```

> Или наоборот, мы можем убрать `set`

```csharp
        public int Y
        {
            get
            { 
                return у; 
            }
        }
```

# Уровень доступа к аксессорам.

> Мы можем менять уровень доступа у `get` и `set`

```csharp
        public int Y
        {
            get
            { 
                return у; 
            }
            private set // Тут добавили private
            {
                if (value < 1)
                {
                    value = 1;
                    return;
                }
                if (value > 5)
                {
                    value = 5;
                    return;
                }

                у = value; 
```

> В результате поле Y есть, просто поменять значение на уровне экземпляра класса мы не можем из-за `private`

![[Pasted image 20251029143459.png]]

# #Автоматические_Свойства

> Допустим у нас никакой сложной логики нет, мы просто хотим получить читать переменную и читать ее.

> Но это слишком громоздкий код:
```csharp
        private int z;

        public int Z
        {
            get { return z; }
            set { z = value; }
        }
```

#Автоматические_Свойства  для этого и нужны

>пишем #снипет `prop` 

```csharp
	public int Z { get; set; }
```

то же самое что и обычные свойства свойства.

> С ними можно делать всё то же самое что и с обычными свойствами:
> Менять модификаторы, частично реализовывать и т.д.

```csharp
	public int Z { private get; }
```
