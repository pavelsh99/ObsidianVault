---
tags:
  - csharp
  - ООП
date: 2026-02-20
---
[Обобщения в C# | C# generics | generic типы методы и классы | C# ОТ НОВИЧКА К ПРОФЕССИОНАЛУ | # 83](https://www.youtube.com/watch?v=TLMwNFCcqVo&list=PLQOaTSbfxUtD6kMmAYc8Fooqya3pjLs1N&index=104)
#  Что такое обобщения

Обобщения - это конструкции языка C#, которые позволяют писать код, который будет работать с различными типами данных.

> Generics позволяют избежать упаковки и распаковки значимых типов, что увеличивает производительность.

[[82.УПАКОВКА И РАСПАКОВКА ЗНАЧИМЫХ ТИПОВ. BOXING UNBOXING]]

> Обобщения позволяют использовать один код, который может работать с разными типами данных. То есть не нужно использовать перегрузку методов и писать код под каждый тип данных. Или не потребуется писать какой-то класс для каждого типа данных.

>Код таким образом легче поддерживать.

# Когда могут понадобиться обобщения:

```csharp
    internal class Program
    {
        static void Main(string[] args)
        {
            int a = 1, b = 5;
            
            Console.WriteLine($"a = {a}\t b = {b}");

            Swap(ref a, ref b);

            Console.WriteLine($"a = {a}\t b = {b}");
        }
        static void Swap(ref  int a, ref int b)   // SWAP
        { 
            int temp = a;
            a = b;
            b = temp;
        }
    }
```

У нас есть метод `Swap`, меняющий значения переменных по ссылке.

Но что если нам необходимо работать с другими типами данных

Мы можем написать перегрузку для метода:

```csharp
        static void Swap(ref double a, ref double b)
        {
            double temp = a;
            a = b;
            b = temp;
        }
```

Но что если нам необходимо поменять логику метода?
Теперь предстоит менять все перегрузки, для всех типов данных а это неудобно.

# Модифицируем метод с Generics

```csharp
        static void Swap<T>(ref T a, ref T b)
        {
            T temp = a;
            a = b;
            b = temp;
        }
```

Теперь метод `swap` работает с любыми типами данных.

При этом мы сохраняем строгую типизацию. Это значит что мы не можем передать в качестве параметров н-р `double a` и `int b`

Параметры должны быть одного типа

![[Pasted image 20260220114113.png]]

# JIT(just in time) компиляция и дженерики:

Когда мы вызываем метод `swap`  для разных типов данных, под копотом генерируется уникальный код для каждого типа данных
- IL код just in time компилируется в байт-код
- Каждый раз когда байт-код генерируется для разных типов данных, столько раз, сколько мы его вызываем.
- И когда мы не вызываем этот метод с каким то типом данных, то байт код не будет скомпилирован.

Такой метод позволяет избежать упаковку и распаковку.

# Дефолтное значение `<T>`

Что будет при вызове такого метода?

```csharp
        static T Foo<T>()
        {
            return default(T);
        }
```

![[Pasted image 20260220115548.png]]

![[Pasted image 20260220115627.png]]

```csharp
Foo<int>(); 
```

Почему нам нужно указать тип данных явно?

Ответ: потому что компилятору не понятно, что мы хотим получить, и какое дефолтное значение вернуть(н-р если `int`, то это `0`, а если `string` или класс, то это `null`)

# Обобщенные классы и коллекции


```csharp
List<int> list = new List<int>(); 
```

Лист это обобщенная коллекция, есть и другие.

По сути лист это класс внутри которого массив.

У него реализованы методы: 
```csharp
List<int> list = new List<int>(); 
            list.Add(1);
            list.Add(2);
            Console.WriteLine(list[0]);
```

Этот лист тоже использует обобщения, т.к., он может работать с любыми типами данных.

Аналог листа в необобщенных коллекциях - это `ArrayList`
```csharp
            ArrayList list = new ArrayList();
            list.Add(1);
            list.Add("Hello");
            list.Add(5.1);
```

Он вызывает много сложностей и не используется.

