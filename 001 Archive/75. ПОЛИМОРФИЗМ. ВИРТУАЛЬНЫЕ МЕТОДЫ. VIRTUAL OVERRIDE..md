---
tags:
  - csharp
  - полиморфизм
  - ООП
date: 2025-12-11
---
[# Полиморфизм | виртуальные методы c# | virtual override c# | C# ОТ НОВИЧКА К ПРОФЕССИОНАЛУ | # 75](https://www.youtube.com/watch?v=xH61vpBebjw)
# Для чего #полиморфизм 

У нас есть `class Car` с методом `Drive()`
```csharp
    class Car
    {
        public void Drive()
        {
            Console.WriteLine("Я машина и я еду");
        }
    }
```

Мы можем унаследовать `class Car` и там будет присутствовать наш метод.

Но что если при наследовании, мы хотим чтобы наш метод работал по-другому.

С помощью `VIRTUAL и OVERRIDE` мы можем переопределить работу класса при наследовании 

Возможно, в коде у нас уже используется `class Car` и мы не можем унаследоваться от класса и изменить метод: 
 ```csharp
     class Person
    {
        public void Drive(Car car)
        {
            car.Drive();
        }
    }
 ```

```csharp
        static void Main(string[] args)
        {

            Person person = new Person();

            person.Drive(new Car());

        }
``` 

У нас может быть еще например другой класс `SportCar`, где есть другой метод

```csharp
    class SportCar : Car
    {

    }
```

И чтобы не применять изменения в разных местах мы можем применить `virtual` 
и `override`

# `virtual` и `override` переопределение методов

Чтобы применить `virtual` нам нужно добавить модификатор к методу:

```csharp
    class Car
    {
        public virtual void Drive()//ТУТ
        {
            Console.WriteLine("Я машина и я еду");
        }
    }
```

пока ничего не поменялось, ведь мы не переопределили метод

Мы лишь добавили такую возможность

Теперь переопределим метод `Drive()` для класса `SportCar`

```csharp
    class SportCar : Car
    {
        public override void Drive()
        {
            base.Drive();
        }
    }
```

В VS слово `override` дает нам возможность выбрать, какой метод мы хотим переопределить:
![[Pasted image 20251211234905.png]]

```csharp
       public override void Drive()
        {
            base.Drive();
        }
```

`base` добавилось автоматически, оно как `this` повторит логику метода `Drive` из 
класса `Car`
[[72. КЛЮЧЕВОЕ СЛОВО BASE. НАСЛЕДОВАНИЕ И КОНСТРУКТОР КЛАССА.]]

В данном случае оно не нужно

```csharp
    class SportCar : Car
    {
        public override void Drive()
        {
            Console.WriteLine("Я машина и я ОЧЕНЬ БЫСТРО еду");
        }
    }
```

Теперь, попробуем вызвать у наследника `Car` - `Person` метод `Drive`, но передать туда `SportCar`:

```csharp
        static void Main(string[] args)
        {

            Person person = new Person();

            person.Drive(new SportCar());

        }
```

На вывод мы получили: `Я машина и я ОЧЕНЬ БЫСТРО еду`

>Теперь в зависимости от того какой класс мы передадим  в качестве параметра  типу `Person`, вызовется разная реализация метода `Drive()`
>При этом мы не меняем код класса `Person`

# Что будет если не переопределять метод

Если мы не будем переопределять метод, а просто оставим метод `Drive`, то будет вызваться метод у базового класса.
```csharp
     class Person
    {
        public void Drive(Car car)//тут
        {
            car.Drive();
        }
    }
```

Потому, что в качестве параметра `Person` примет именно базовый класс.

# Полиморфизм и  модификатор `protected`



Допустим у нас еще есть `protected` метод у базового класса `Car`
```csharp
    class Car
    {
        protected virtual void StartEngine()
        {
            Console.WriteLine("двигатель запущен");
        }
        public virtual void Drive()
        {
            Console.WriteLine("Я машина и я еду");
        }
    }
```

А метод `Drive()`у `Car` и `SportCar` его использует:

```csharp
        public virtual void Drive()
        {
            StartEngine();
            Console.WriteLine("Я машина и я еду");
        }
```

```csharp
    class SportCar : Car
    {
        public override void Drive()
        {
            StartEngine();
            Console.WriteLine("Я машина и я ОЧЕНЬ БЫСТРО еду");
        }
    }
```

Мы так же можем его переопределить в классе `SportCar`

```csharp
    class SportCar : Car
    {
        protected override void StartEngine()
        {
            Console.WriteLine("РЕВ МОТОРА");
        }
        public override void Drive()
        {
            StartEngine();
            Console.WriteLine("Я машина и я ОЧЕНЬ БЫСТРО еду");
        }
    }
```

> Чтобы это сделать мы должны использовать тот же модификатор доступа, то есть `protected` и слово `override`

Теперь при передаче `SportCar` в качестве аргумента  метода `Drive` у класса`Person` логика изменится.

>Важная деталь: если бы модификатор доступа был `private`, то мы бы не смогли его использовать в наследнике и тем более переопределить.