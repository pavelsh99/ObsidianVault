---
date: 2025-09-26
tags:
  - типы_данных
  - csharp
---
[Что такое Nullable | Null совместимые значимые типы Nullable | C# ОТ НОВИЧКА К ПРОФЕССИОНАЛУ | # 52](https://www.youtube.com/watch?v=jhz3Ltc09m4)

### ПРОБЛЕМА: ОГРАНИЧЕНИЕ ТИПОВ ДАННЫХ. ЗАЧЕМ НУЖЕН NULLABLE?

>`Nullable` создан  изначально для значимых типов данных, чтобы они могли хранить `null`

> В C# 8.0+ есть возможность применять `nullable` и для ссылочных типов, но работает по-другому

>Ссылочные типы хранят в стеке ссылку на значение, в отличие от значимых типов, которые в стеке хранят реальные данные. Поэтому ссылочные типы могут хранить `null`, а значимые - нет.

>Т.Е при использовании ссылочных типов в стеке есть ссылка на данные в управляемой куче, но самих данных нет

![[Pasted image 20250926010459.png]]

```csharp
string str = null;

int i = null;        // Ошибка компиляции

DateTime date = null; // Ошибка компиляции
```

##### Пример:

Неспособность хранить `null` становится проблемой, когда данные поступают из систем, где отсутствие значения — это норма. Классический пример — SQL-база данных.

В таблице пользователей поле `ДатаРождения` может быть `NULL`, если эта информация неизвестна. При извлечении такой записи в C#-приложение возникает неоднозначность:

• Какое значение присвоить переменной типа `DateTime`?

• Если присвоить значение по умолчанию (например, `01.01.0001`), как отличить его от реальной, хотя и маловероятной, даты рождения?

Эта ситуация затрудняет точное моделирование данных и приводит к необходимости создавать обходные пути. Именно для решения этой проблемы в C# были введены Nullable-типы.

### РЕШЕНИЕ

Nullable-типы представляют собой элегантное решение, позволяющее значимым типам хранить значение `null`. Это дает возможность более точно моделировать данные из реального мира, где информация может отсутствовать.

>Для объявления Nullable-типа после названия базового значимого типа добавляется знак вопроса (`?`)

```csharp
string str = null;

int? i = null;        // Нет ошибки компиляции

DateTime? date = null; // Нет ошибки компиляции
```

![[Pasted image 20250926011642.png]]

### Изменения со значимым типом метода при превращении его в `nullable`.

1) Появляется поле `.HasValue`.
Это `bool` которая определяет есть ли в переменной значение.

```csharp
int? i = null;
i.HasValue // false

int? b = 3;
i.HasValue // true
```

2) Появляется поле `.Value`
Это реальные данные, которые хранятся в переменной.

```csharp
int? i = null;
i.Value // InvalidOperationExeption

int? b = 3;
i.Value // = 3
```


##### Примеры операций:

 - проверка на `null`
```csharp
int? i = null;

Console.WriteLine(i == null); // True

Console.WriteLine(i.HasValue); // False
```

- Безопасное извлечение значения у `nullable`
```csharp
int? i = null;

Console.WriteLine(i.GetValueOrDefault()); // 0

Console.WriteLine(i.GetValueOrDefault(3)); // 3

int? b = 1;

Console.WriteLine(b.GetValueOrDefault()); // 1

Console.WriteLine(b.GetValueOrDefault(3)); // 1

```

- Безопасное извлечение значения у `nullable` с помощью [[40. ОПЕРАТОР ОБЪЕДИНЕНИЯ С NULL]]
```csharp
int? i = null;

Console.WriteLine(i ?? 55); // 55

int? b = 1;

Console.WriteLine(b ?? 55); // 1
```
*читается как "если `i = null` верни 55"*
>В подавляющем большинстве случаев оператор `??` является лучшим выбором для безопасного извлечения значения или предоставления значения по умолчанию.

- Предупреждение об опасности
>Всегда помните, что прямой доступ к свойству `.Value` без предварительной проверки на `null` или `HasValue` является рискованным и может привести к падению приложения с исключением `InvalidOperationException`.
```csharp
int? i = null;
Console.WriteLine(i.Value);//InvalidOperationException
```

### Операции с nullable. 
##### 1) Арифметические

>Ключевое правило здесь очень простое: любая арифметическая операция (+, -,* ,* /) с участием null в качестве одного из операндов всегда возвращает null. Эта концепция известна как "lifted operators" и гарантирует, что неопределенность (`null`) распространяется по цепочке вычислений.

```csharp
int? a = 10;
int b = 7;
int? result = a + b; // 17

//////////////////////////////////

int? a = null;
int b = 7;
int? result = a + b; // null
```

##### 2) Операции сравнения

Логика сравнения с `null` следует двум ключевым правилам:

>1. Сравнение null с не-null значением: При сравнении Nullable-переменной, содержащей `null`, с любым реальным значением с помощью операторов `<`, `>`, `<=`, `>=` и `==`, результат всегда будет false. Логика в том, что `null` не означает "ноль", а "отсутствие значения", поэтому оно не может быть ни больше, ни меньше, ни равно какому-либо конкретному значению.

```csharp
int? a = null;
int b = 7;
bool result = a == b; // False
```

>2. Сравнение null с null: Операторы `==` и `!=` являются исключением и работают интуитивно для проверки на `null`. Сравнение `variable == null` вернет `true`, если переменная действительно `null`, а `variable != null` вернет `false`.


```csharp
int? a = null;
bool result = a == null; // True
bool result = a != null; // False
```


