---
tags:
  - csharp
  - ключевое_слово
date: 2025-09-28
---

### `var` - это не тип данных

>`Var` это не тип данных. Это синтаксический сахар.

>Это ключевое слово указывает компилятору что он сам должен определить тип данных переменной, в зависимости от того что мы помещаем в нее.

```csharp
var a = 5;
Console.WriteLine(a.GetType()); // System.Int32

var b = "hello";
Console.WriteLine(b.GetType()); // System.String

var c = new float[10];
Console.WriteLine(c.GetType()); //System.Single[]
```

>В C# есть универсальный инструмент — метод `.GetType()`, который есть у любой переменной. Он позволяет в любой момент узнать её истинный тип. Например, если мы выведем результат `myNumber.GetType()`, то увидим в консоли `System.Int32` — полное системное имя для типа `int`. Это отличный способ проверить, как компилятор «увидел» ваш код.

### Строгая типизация никуда не делась

>Использование `var` **не отменяет строгую типизацию** в C#. Это критически важный момент. Тип переменной определяется только один раз — в момент её создания. После этого изменить его уже невозможно.

```csharp
var myVariable = "Это строка"; 
myVariable = 123; // ОШИБКА: Невозможно неявно преобразовать тип "int" в "string"
```

>Эта строгая, однократная привязка к типу — ключевое отличие `var` от настоящего динамического типа `dynamic`, с которым вы познакомитесь позже. `dynamic` позволяет менять тип «на лету», а `var` — нет.

### Когда есть польза от `var`. Пример №1

>Использовать `var` стоит не всегда. Он приносит реальную пользу в конкретных сценариях, делая код чище и короче.

>Иногда названия типов могут быть очень длинными, особенно при работе с коллекциями, такими как словари (`Dictionary`). `var` помогает избежать дублирования и делает код лаконичнее.
##### Как было

```Csharp
Dictionary<int, string> t = new Dictionary<int, string>();
```

##### Как стало

```csharp
var t = new Dictionary<int, string>();
```

> Есть и еще одно преимущество, помимо удобства: если нужно изменить тип (например, с `Dictionary<int, string>` на `Dictionary<long, string>`), вам придется сделать это только в одном месте, а не в двух. Это упрощает поддержку кода.

### Пример №2

>В C# есть возможность создавать объекты «на лету», у которых даже нет заранее определенного имени класса. Они называются **анонимными типами**.

```csharp
var t = new { Name = "Саша", Age = 22 };
Console.WriteLine(t.GetType());
//<>f__AnonymousType0`2[System.String,System.Int32]
```

### Пример №3 LINQ

>При работе с запросами LINQ результаты запросов часто имеют очень сложные, автоматически сгенерированные типы. Указывать их вручную было бы крайне неудобно.

```csharp
int[] numbers = { 10, 20, 5, 17, 30 };

// Выбираем все числа больше 15
var selection = from n in numbers
                where n > 15
                select n;
```

### Где var не работает

>Несмотря на свою полезность, `var` имеет строгие правила использования. Главное из них: `var` можно использовать **только для локальных переменных** (то есть переменных, объявленных внутри метода).

![[Pasted image 20250928125240.png]]

![[Pasted image 20250928125313.png]]

![[Pasted image 20250928125515.png]]

• **Как тип для полей класса.** Поля должны иметь четко определенный тип, видимый во всей структуре класса.

• **Как тип для параметров метода.** _Причина:_ Представьте метод `public void MyMethod(var input)`. Как компилятору понять, что можно делать с переменной `input` внутри метода? Можно ли ее складывать с числом? Или брать у нее свойство `.Length`? Неизвестно. Контракт метода должен быть ясен заранее, поэтому тип параметра должен быть указан явно.

• **Как возвращаемый тип метода.** _Причина:_ Сигнатура метода (его «контракт») должна быть однозначной. Тот, кто вызывает метод, должен точно знать, какой тип данных он получит в ответ.