---
tags:
  - csharp
  - интерфейсы
  - ООП
  - наследование
date: 2026-02-14
---
[Наследование интерфейсов C# | множественное наследование интерфейсов | C# ООП | # 78](https://www.youtube.com/watch?v=V3eZX-nDQBk&list=PLQOaTSbfxUtD6kMmAYc8Fooqya3pjLs1N&index=99)
# Что такое наследование интерфейсов?

> Это не наследование интерфейсов, это реализация
```csharp
{
    interface IWeapon
    {
        void Fire();
    }
    class Gun : IWeapon
    {
        public void Fire()
        {
            Console.WriteLine($"{GetType().Name}: БУМ!");
        }
    }
```

Наследование интерфейсов, это когда интерфейсы наследуются от друг-друга:

```csharp
    interface IWeapon
    {
        void Fire();
    }

    interface IThrowingWeapon : IWeapon // Тут
    {
        void Throw();

    }
```

При наследовании интерфейсов, принцип тот же самый как при наследовании классов: то есть интерфейс наследник будет иметь все те же свойства и методы что и базовый:

```csharp
    class Kinfe : IThrowingWeapon
    {
        public void Fire() // ОТ IWeapon
        {
            Console.WriteLine($"{GetType().Name}: СЛЕШ!");
        }

        public void Throw() // ОТ IThrowingWeapon
        {
            Console.WriteLine($"{GetType().Name}: Нож со свистом воткнулся!");
        }
    }
```

> Но в отличие от классов, интерфейсы поддерживают множественное наследование. И он будет содержать всё, что было в его предках

# Пример

У нас есть игра, где есть игрок и разные оружия.

```csharp
    class Player
    {
        public void Fire(IWeapon weapon)
        {
            weapon.Fire();
        }
    }
```

Игрок должен уметь стрелять из любого из них.

```csharp
    interface IWeapon
    {
        void Fire();
    }
    
    class Gun : IWeapon
    {
        public void Fire()
        {
            Console.WriteLine($"{GetType().Name}: БУМ!");
        }
    }
    class LaserGun : IWeapon
    {
        public void Fire()
        {
            Console.WriteLine($"{GetType().Name}: ПИУ!");
        }
    }
```

Любой класс, реализующий интерфейс `IWeapon` обязан содержать метод
`void Fire()`

А если там есть метод `Fire()` то мы можем передать это нашему игроку.

В `Main` мы создаем объект класса `Player()` и массив типа `IWeapon`, который может хранить объекты, где есть реализация этого интерфейса.

Мы перебираем этот массив циклом и помещаем в метод `player.Fire(weapon)` каждое оружие.

```csharp
        static void Main(string[] args)
        {
            Player player = new Player();
            IWeapon[] inventory = {new Gun(), new LaserGun()};
            
            foreach (IWeapon weapon in inventory)
            {
                player.Fire(weapon);
                Console.WriteLine();
            }
        }
```


# Проблема и решение.

Но что, если нам нужно добавить новый тип оружия, Нож?

Нож можно бросить, а можно им ударить.

У нас уже есть логика стрельбы, и мы не хотим ее поломать.

Также необходимо, чтобы наш инвентарь мог хранить этот нож.

> Тут нам поможет наследование интерфейсов.

```csharp
    interface IThrowingWeapon : IWeapon
    {
        void Throw();
    }
```

Наследуемся от интерфейса `IWeapon`

И реализовываем новый интерфейс `IThrowingWeapon` (_так и его предка `IWeapon`)

```csharp
    class Kinfe : IThrowingWeapon // Вот
    {
        public void Fire() // Метод Fire остался
        {
            Console.WriteLine($"{GetType().Name}: СЛЕШ!");
        }

        public void Throw()
        {
            Console.WriteLine($"{GetType().Name}: Нож со свистом воткнулся!");
        }
    }
```

Теперь, наш инвентарь может хранить новый тип оружия, не меняя всю остальную логику. 

```csharp
        static void Main(string[] args)
        {
            Player player = new Player();
            IWeapon[] inventory = {new Gun(), new LaserGun(), new Kinfe()};
            
            foreach (IWeapon weapon in inventory)
            {
                player.Fire(weapon);
                Console.WriteLine();
            }
        }
```
 
Нож может храниться в инвентаре, т.к. в нем реализован метод `Fire`.

Теперь мы можем даже добавить игроку новый метод `Throw`  и даже новые метательные оружия
```csharp
    class Player
    {
        public void Fire(IWeapon weapon)
        {
            weapon.Fire();
        }
        
        public void Throw(IThrowingWeapon weapon) // Тут
        { 
            weapon.Throw(); 
        }
    }
```