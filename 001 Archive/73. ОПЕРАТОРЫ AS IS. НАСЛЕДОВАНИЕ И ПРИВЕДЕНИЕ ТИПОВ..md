---
tags:
  - csharp
  - ООП
  - наследование
  - оператор
date: 2025-12-07
---
[Операторы as is c# | наследование и приведение типов в C# | C# ОТ НОВИЧКА К ПРОФЕССИОНАЛУ | # 73](https://www.youtube.com/watch?v=tO7ohK6vTw4&list=PLQOaTSbfxUtD6kMmAYc8Fooqya3pjLs1N&index=93)
# Тип данных `object` как базовый тип для всех типов данных

>В C# все типы данных неявно унаследованы от типа данных `object`.

>`object` - базовый тип данных для всех других типов данных.

Если бы была возможность записать это явно, то это выглядело бы так:

![[Pasted image 20251207155518.png]]

> Любой производный тип можно сохранить в ссылке базового класса.

> То есть объект любого класса и любой тип данных можно записать в `object`

```csharp
object point = new Point2D(x: 10, y: 20); 
object a = "Hello";
object b = 123;
```

> Данный принцип сохраняется при любой схеме наследования

```csharp
    class Point2D : Object
    {
        public int X { get; set; }
        public int Y { get; set; }

        public Point2D(int x, int y)
        {
            X = x;
            Y = y;
        }

        public void Print()
        {
            Console.WriteLine($"X: {X}, Y: {Y}");
        }
    }
    class point3D : Point2D
    {
        public int Z { get; set; }
        public point3D(int x, int y, int z) : base(x, y)
        {
            Z = z;
        }
        public new void Print()
        {
            Console.WriteLine($"X: {X}, Y: {Y}, Z: {Z}");
        }
    }
```

То есть в базовый класс мы можем присвоить тип наследника:
```csharp
        public static void Main(string[] args)
        {
            object obj = new Point3D(1, 2, 3);
            Point2D point2D = new Point3D(1, 3, 2);
        }
```

# Неявное приведение типов

Такая операция и есть неявное приведение типов.

```csharp
        public static void Main(string[] args)
        {
            object obj = new Point3D(1, 2, 3);
            Point2D point2D = new Point3D(1, 3, 2);
        }
```

Потому что мы нигде явно не указываем, что мы хотим перевести один тип в другой.

А тот факт что ссылка на базовый класс может хранить наследников, делает эту операцию безопасной.

# Явное приведение типов.

Нюанс: после того как мы поместили `Point3D` в ссылку на `object`, мы видим что там нету ни полей `X` `Y` ни метода `Print()`:

![[Pasted image 20251207163349.png]]

Всё потому что базовый `object` ничего не знает про наследника.

## Но что если нам понадобился функционал `Point3D`, который там находится? Нам нужно выполнить явное приведение типов:

```csharp
object obj = new Point3D(1, 2, 3);   

Point3D point = (Point3D)obj;

point.Print();
```

![[Pasted image 20251207164349.png]]

То есть мы создали объект`point` класса `Point3D`, записали туда `obj` и явно указали что это объект`Point3D`.

Но почему мы не можем сделать так?

![[Pasted image 20251207164452.png]]

Потому что такое преобразование небезопасно, и когда мы пишем: 
`Point3D point = (Point3D)obj;`
мы берем всю ответственность на себя.

Ведь у базового `object` много наследников и например мы можем туда присвоить строку или вообще любой тип данных:
![[Pasted image 20251207165016.png]]

и когда мы попытаемся засунуть строку в `Point3D` мы получим исключение, ведь там есть только поля `X`, `Y` и `Z`.

![[Pasted image 20251207165128.png]]

Для решения таких проблем и придуманы операторы `as` и `is`.
# Операторы `as` `is`:

## Оператор `as` 

```csharp
public static void Main(string[] args)
{
    object obj = new Point3D(1, 2, 3); 
}


static void Foo(object obj)
{
    Point3D point = obj as Point3D;
    if (point != null)
    {
        point.Print();
    }
}
```

С помощью оператора `as` мы преобразуем объект в переменную типа `Point3D`

Разница между явным преобразованием со скобками и использованием `as` в том, что если в случае`Point3D point = (Point3D)obj;` туда попадет что-то иное, а не `Point3D`, то это вызовет исключение.

А если в случае с `as` туда попадет что-то, то туда присвоится `null`.

Поэтому в методе `Foo(object obj)` мы проверяем на `null`, потому что если не `null`, то конвертация прошла успешно и код отработает.

# Оператор `is`

Оператор `is` работает по-другому, 
```csharp
        static void Bar(object obj)
        {
            if (obj is Point3D point3D)// тут
            {
                point3D.Print();
            }
        }
```

он возвращает результат проверки как переменную `bool` и если она успешна может сразу же записать ее в нужный тип данных 

![[Pasted image 20251207173927.png]]

point3D это имя объекта 
