---
tags:
  - csharp
  - ключевое_слово
  - ООП
date: 2025-11-01
---
[Статические методы C# | Статические свойства C# | как работает ключевое слово static | C# ООП | # 64](https://www.youtube.com/watch?v=EWMfxcnWOOo&list=PLQOaTSbfxUtD6kMmAYc8Fooqya3pjLs1N&index=84)
# Ключевое слово `static` и его влияние на поведение методов

> Принцип работы `static` методов схож с работой `static` полей [[63.СТАТИЧЕСКИЕ ПОЛЯ КЛАССА. КАК РАБОТАЕТ КЛЮЧЕВОЕ СЛОВО STATIC]]

> Так же как и с полями `static`методы можно использовать не создавая экземпляр класса

```csharp
    class Myclass
    {
        private static int a;
        private int b;

        public static void Foo()
        {

        }
        public void Bar()
        {

        }
    }
```

![[Pasted image 20251101131318.png]]

![[Pasted image 20251101131408.png]]

> Статические методы недоступны на уровне экземпляра класса.

> Внутри `static` метода, мы можем вызывать только `static` переменные.

![[Pasted image 20251102205533.png]]

![[Pasted image 20251102205736.png]]

> Но внутри обычных методов мы можем вызвать `static` методы и поля

```csharp
        public static void Foo()
        {
            Console.WriteLine("Вызван метод Foo");
            
        }
        public void Bar()
        {
            Console.WriteLine("Вызван метод Bar");
            Foo();
        }
```

# Пример использования методов `static`

> Теперь мы понимаем что такое  
```csharp
Console.Writeline();
```
>
>Это `static` метод, для использования которого, нам не нужно создавать экземпляр класса. 

>Другой пример:

```csharp
Array.Copy();
```

![[Pasted image 20251103001253.png]]

> `static` методы чаще всего используются для создания утилитарных вещей, таких как поиск, сортировка, и т.д.
---------------

# Немного про #полиморфизм 

> При использовании ключевого слова `static` для методов, мы теряем возможность использовать полиморфизм для ООП в его классическом понимании.
>
>Потому что полиморфизм требует создания объекта класса и вызова метода на уровне этого экземпляра. 
>
>А `static` не позволяет вызывать метод через объект класса.

# Об других `static` членах класса

> События `event` тоже могут быть статическими, но об этом в соответствующем уроке [[89. СОБЫТИЯ (EVENTS)]]

## STATIC СВОЙСТВА [[62. СВОЙСТВА GET SET. КЛЮЧЕВОЕ СЛОВО VALUE. АВТОМАТИЧЕСКИЕ СВОЙСТВА]]

> Свойства это методы `get` и `set` обращение к которым идет как будто к полю через объект класса.
> 
> Свойства организуют работу с полем для правильной работы с ним через методы, так как мы задумали
> 
> Т.К свойства это методы, то к ним можно применить модификатор `static`
> 
> Тогда к `static` свойствам  можно будет обращаться на уровне класса


Пример простого свойства:

```csharp
class Myclass
{
    public static int a
    {
        get { return a; }
        set { a = value; }
    }
}
```

> Обращение на уровне класса а не объекта класса

![[Pasted image 20251103003548.png]]

>Пример авто-свойства:

```csharp
public static int C { get; set; }
```

> Модификация `static` свойств и частичная реализация работают как с обычными 

# Пишем свой `static` метод `Counter` с свойствами.

```csharp
    class MyClass
    {
        public MyClass()
        {
            counter++;
        }
        private static int counter;

        public static int Counter
        {
            get { return counter; }
            set { counter = value; }
        }
    }
```

> Создали `staric` свойство `counter` и Конструктор, который добавляет `+1` каждый раз, когда мы создаем экземпляр класса

```csharp
        static void Main(string[] args)
        {
            MyClass myclass = new MyClass();
            MyClass myclass1 = new MyClass();
            MyClass myclass2 = new MyClass();

            Console.WriteLine(MyClass.Counter);
        }
```

> Проверяем работу, создав 3 экземпляра класса и вызвав `counter`.

![[Pasted image 20251103005404.png]]

> Но мы можем случайно нарушить логику класса, 
> 
> Сейчас, мы можем напрямую обратиться к свойству в `Main` и поставить любое число, нарушая инкапсуляцию.

```csharp
static void Main(string[] args)
{
	MyClass.Counter = 1111;
}
```

> Нам нужно либо убрать метод `set` из свойств

```csharp
        public static int Counter
        {
            get { return counter; }
            
        }
```

> Либо добавить модификатор `private` к свойству `set`

```csharp
        public static int Counter
        {
            get { return counter; }
            private set { counter = value; }
        }
```

> Добавив `private` перед методом `set` мы не можем менять `Counter` и сохраняем инкапсуляцию

![[Pasted image 20251103010108.png]]

> Или можем написать свой метод, возвращающий `counter`

```csharp
	class MyClass
	{
        public static int GetCounter()
        {
            return counter;
        }
    }
       static void Main(string[] args)
	{
		Console.WriteLine(MyClass.GetCounter());
	} 
```

> Или сделать обычный метод выводящий `Counter` на уровне объекта класса

```csharp
	class MyClass
	{
        public  int GetCounter()
        {
            return counter;
        }
    }
       static void Main(string[] args)
	{
		MyClass myclass = new MyClass();
		Console.WriteLine(myclass.GetCounter());
	} 
```

> Также мы можем ввести обычное свойство, которое будет возвращать `static` `counter`, но на уровне объекта.

```csharp
        public  int objCount
        {
            get { return counter; }
            private set { counter = value; }
        }
        
    static void Main(string[] args)
	{
		MyClass myclass = new MyClass();
		Console.WriteLine(myclass.objCount());
	} 
```

> ***Это был пример реализации  функционала `static` методами и свойствами***