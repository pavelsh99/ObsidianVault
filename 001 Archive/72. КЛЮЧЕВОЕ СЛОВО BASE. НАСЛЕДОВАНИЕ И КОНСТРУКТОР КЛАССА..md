---
tags:
  - csharp
  - ООП
  - наследование
date: 2025-12-05
---
[Ключевое слово base в C# | наследование и конструктор класса | C# ОТ НОВИЧКА К ПРОФЕССИОНАЛУ | # 72](https://www.youtube.com/watch?v=wr_adG-biuc&list=PLQOaTSbfxUtD6kMmAYc8Fooqya3pjLs1N&index=92)
# Пример

```csharp
    class Point2D
    {
        public int X {  get; set; }
        public int Y { get; set; }

    }
    class Point3D : Point2D
    {
        public int Z { get; set; }
    }
```

У нас есть 2 класса базовый `Point2D` и наследник:`Point3D` 

Создадим явные конструкторы для классов, чтобы наглядно посмотреть когда они вызываются, при создании объекта класса:

```csharp
    class Point2D
    {
        public Point2D()//тут
        {
            Console.WriteLine("Вызван конструктор Point2D");
        }
        public int X {  get; set; }
        public int Y { get; set; }

    }
    class Point3D : Point2D
    {
        public Point3D()//тут
        {
            Console.WriteLine("Вызван конструктор Point3D");
        }
        public int Z { get; set; }
    }
```

Теперь в `Main` создадим объект класса `Point3D`

```csharp
        static void Main(string[] args)
        {
            Point3D point3D = new Point3D();
        }
```

Вывод на консоль:
![[Pasted image 20251205184504.png]]

Получилось что 2 конструктора было вызвано, хоть мы не создавали объект `Point3D`

>Таким образом при создании наследника создается предок.

Порядок вызова конструктора при наследовании таков:
	сначала конструируется предок
	потом конструируется наследник

# `Base` ключевое слово

Модифицируем конструктор  класса `Point2D`.

```csharp
        public Point2D(int X,int Y)
        {
            this.X = X;
            this.Y = Y;
            Console.WriteLine("Вызван конструктор Point2D");
        }
```

теперь мы не можем создать объект класса `Point2D` без указания параметров

Но это значит, что мы не можем теперь создать объект класса наследника
(`Point3d`).

![[Pasted image 20251207012909.png]]

Нам поможет ключевое слово `Base` в конструкторе наследника - `Point3D`

```csharp
    class Point3D : Point2D
    {
        public Point3D() : base(X:0, Y:0)
        {
            Console.WriteLine("Вызван конструктор Point3D");
        }
        public int Z { get; set; }
    }
```

![[Pasted image 20251207013138.png]]

Среда разработки говорит нам, что это на самом деле конструктор  класса`Point2D`

>Таким образом мы можем явно указать какой конструктор у базового класса мы используем. И какие параметры мы хотим передать. 

как сделать, чтобы мы могли создавать объект `Point3D` сразу с параметрами?

```csharp
    class Point3D : Point2D
    {
        public Point3D(int X, int Y, int Z) : base(X:X, Y:Y)
        {
	        this.Z = Z;
            Console.WriteLine("Вызван конструктор Point3D");
        }
        public int Z { get; set; }
    }
```

Теперь мы можем передавать данные, которые соответствуют полям которые должны храниться в таком объекте

С полями `X` и `Y` справится базовый класс, поэтому в `base` мы передаем `base(X,Y)` а не конкретные значения.

То есть мы передаем в конструктор `Point3D` поля`X,Y,Z`,  а `base` передает значения `X,Y` конструктору базового класса.

# Другое использование `base`

С помощью `base` мы можем наследовать так же и например методы:

Допустим у нас есть метод, который выводит на консоль поля `Point2D`

```csharp
        public void Display2D()
        {
            Console.WriteLine($"X={X}\nY={Y}");
        }
```

Мы хотим добавить метод в класс `Point3D`, который будет выводить поля `Point2D` и поле `Z` из `Point3D`

```csharp
        public void Display3D()
        {
            base.Display2D();
            Console.WriteLine($"\nZ={Z}");
        }
```

![[Pasted image 20251207020529.png]]

Мы видим что`base` подсвечивается тускло
Оно работает схожим образом с `this`, то есть тут мы можем явно не указывать.

Но в случае неоднозначности, оно может пригодиться:

```csharp
		// класс 2д
        public void Display()
        {
            Console.WriteLine($"X={X}\nY={Y}");
        }
        //класс 3д
        public void Display()
        {
            base.Display();
            Console.WriteLine($"\nZ={Z}");
        }
```

без его использования мы бы получили ошибку
![[Pasted image 20251207021035.png]]

Это из-за того что метод `Display()` внутри класса `Point3D` бесконечно вызывал сам себя и привёл к переполнению стека

`base` явно указывает, что мы хотим вызвать метод из базового класса

## бонус

в любом классе существуют следующие методы, хотя мы их не прописывали:
![[Pasted image 20251207021451.png]]

всё потому что классы наследуются от `Object`

![[Pasted image 20251207021623.png]]


