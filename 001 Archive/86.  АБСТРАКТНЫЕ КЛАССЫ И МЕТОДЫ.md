---
tags:
  - csharp
  - ООП
  - полиморфизм
date: 2026-01-08
---
[Абстрактные классы | зачем нужны абстрактные методы | abstract c# | полиморфизм | C# ООП | # 76](https://www.youtube.com/watch?v=GAq9QrBvVtw&list=PLQOaTSbfxUtD6kMmAYc8Fooqya3pjLs1N&index=97)
# Что такое абстрактный класс.

Абстрактный класс это как бы идея.
Например у нас есть игрок, который может стрелять из оружия. 
И оружие может быть любым, но нам важно чтобы в каждом оружии была логика стрельбы.

Мы хотим научить наш класс `Player` стрелять из любого оружия `Weapon`

```csharp
class Player
{
    public void Fire()
    {
		
    }
}
class Weapon
{
	
}
```

Оружие может быть любым, лук, пистолет, арбалет. Поэтому нам нужен абстрактный базовый класс.

Мы будем использовать класс `Weapon` как некий "контракт", который будут реализовывать его наследники.

`Weapon` это лишь идея, а не конкретное оружие, поэтому он абстрактный.

Так как мы не знаем, что это за оружие, мы не можем написать реализацию метода `Fire()`. (Она нам и не нужна, мы будем делать реализацию для каждого конкретного оружия)

Поэтому сделаем этот метод тоже абстрактным.

```csharp
class Player
{
	public void Fire()
    {
		
    }
}

abstract class Weapon
{
	public abstract void Fire();
	
}
```

>Абстрактные методы могут находиться только внутри абстрактных классов

>Абстрактный метод не может иметь тела (вот этих скобок`{}`)

Теперь, мы будем передавать в метод `Fire()` у `Player` объект типа `weapon` и вызывать у этого объекта абстрактный метод `Fire()`

```csharp
    class Player
    {
        public void Fire(Weapon weapon)
        {
            weapon.Fire();
        }
    }
    abstract class Weapon
    {
        public abstract void Fire();
        
    }
```

Теперь наш класс `Player` будет стрелять чем угодно, что унаследовано от класса `Weapon`

Создадим оружие 
```csharp
    class  Gun : Weapon
    {

    }
```
![[Pasted image 20260108171556.png]]

Нам выдается ошибка, говорящая, что мы должны обязательно реализовать метод.

>Если у нас есть абстрактный класс с абстрактными методами, то его наследники обязаны реализовать его абстрактные методы

Этим мы гарантируем, что `Player` может стрелять из любого наследника `Weapon`

теперь переопределим метод`Fire` для  класса`Gun`

```csharp
    class Gun : Weapon
    {
        public override void Fire()
        {
            Console.WriteLine("Бум");
        }
    }
```

Так выглядит общая картина:

```csharp
    class Player
    {
        public void Fire(Weapon weapon)
        {
            weapon.Fire();
        }
    }
    abstract class Weapon
    {
        public abstract void Fire();
        
    }

    class Gun : Weapon
    {
        public override void Fire()
        {
            Console.WriteLine("Бум");
        }
    }
```

Теперь мы можем передать `player` `gun` и стрелять


```csharp
static void Main(string[] args)
{
    Player player = new Player();
    Gun gun = new Gun();
    player.Fire(gun);
}
```

Создадим другие оружия:
```csharp
    class Cannon : Weapon
    {
        public override void Fire()
        {
            Console.WriteLine("Дыдыщь");
        }
    }
    class LaserGun : Weapon
    {
        public override void Fire()
        {
            Console.WriteLine("Пиу");
        }
    }
    class Gun : Weapon
    {
        public override void Fire()
        {
            Console.WriteLine("Бум");
        }
    }
```

# Полиморфизм в чистом виде

Все эти классы имеют общую деталь. Они унаследованы от абстрактной идеи оружия. Это и есть полиморфизм в чистом виде.

Поэтому по сути это всё один и тот же абстрактный класс `Weapon`. 

```csharp
        static void Main(string[] args)
        {
            Player player = new Player();
            Weapon[] inventory = {new Cannon(), new LaserGun(), new Gun()};

            Console.WriteLine("Из чего стрелять?\n1.Пушка\n2.Лазер\n3.Пистолет");

            int input = int.Parse(Console.ReadLine());

            player.Fire(inventory[input]);
        }
```

Так как это всё один тип, мы можем поместить оружия в массив инвентарь.

# Конкретная реализация абстрактных методов

```csharp
    class Player
    {
        public void Fire(Weapon weapon)
        {
            weapon.Fire();
        }
        public void GetInfo(Weapon weapon)
        {
            weapon.GetInfo(); 
        }
    }
    abstract class Weapon
    {
        public abstract void Fire();
        
        public void GetInfo()
        {
            Console.WriteLine(GetType().Name);
        }
    }
```

Мы добавили обычный метод `GetInfo()` в класс `Weapon` он выводит на консоль информацию о типе переданных в него данных.

В класс `Player` мы добавили другой метод `GetInfo()`, который активирует метод из класса `Gun` при этом передает туда экземпляр класса.