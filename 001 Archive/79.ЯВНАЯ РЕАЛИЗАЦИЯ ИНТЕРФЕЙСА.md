---
tags:
  - csharp
  - ООП
  - интерфейсы
  - вопрос_на_собеседовании
date: 2026-02-15
---
[Интерфейсы в C# | ЯВНАЯ РЕАЛИЗАЦИЯ интерфейса C# | C# ОТ НОВИЧКА К ПРОФЕССИОНАЛУ | # 79](https://www.youtube.com/watch?v=k9XQBLUzNQA&list=PLQOaTSbfxUtD6kMmAYc8Fooqya3pjLs1N&index=100)
# Эта тема встречается не часто, но ее задают на собеседовании:

> Может ли класс реализовать 2 интерфейса у которых объявлено 2 одинаковых метода?
```csharp
interface IFirstInterface
{
    void action();
}
interface ISecondInterface
{
    void action();
}
```
..........................................................................................
```csharp
    internal class Program
    {
        static void Main(string[] args)
        {
        }
        static void Foo(IFirstInterface firstInterface)//метод1
        {
            firstInterface.action();
        }
        static void Bar(ISecondInterface secondInterface)//метод2
        {
            secondInterface.action();
        }
    }
```

1) То есть у нас есть 2 интерфейса и 2 метода.  Метод`Foo` принимает тип, который реализует первый интерфейс, `Bar` принимает тип который реализует второй интерфейс.
2) В теле каждого метода мы вызываем метод `Action()`


Попробуем создать класс и реализовать там `ISecondInterface` и `IFirstInterface`:

```csharp
    public class Myclass : ISecondInterface, IFirstInterface
    {
        public void Action() 
        {
            Console.WriteLine("Myclass action");
        }
    }
```


Создадим экземпляр класса `MyClass()` и попробуем передать его в методы `Foo` и `Bar`
```csharp
        static void Main(string[] args)
        {
            Myclass myclass = new Myclass();
            Foo(myclass);
            Bar(myclass);
        }
        static void Foo(IFirstInterface firstInterface)
        {
            firstInterface.Action();
        }
        static void Bar(ISecondInterface secondInterface)
        {
            secondInterface.Action();
        }
```

 
![[Pasted image 20260215142249.png]]

Код скомпилировался

Результат:
![[Pasted image 20260215142423.png]]


Не смотря на то что в классе реализованы 2 разных интерфейса, сигнатура метода у них одинаковая. Поэтому реализация тоже одинаковая, не смотря на то, что мы реализуем "2 разных интерфейса"

# Как сделать собственную реализацию для каждого интерфейса? ОТВЕТ: -ЯВНАЯ РЕАЛИЗАЦИЯ.

Создадим другой класс:
```csharp
public class MyOtherClass : ISecondInterface, IFirstInterface
{
	
}
```

В VS есть кнопка, которой можно реализовать все элементы интерфейса явно:
![[Pasted image 20260215143137.png]]


```csharp
    public class MyOtherClass : ISecondInterface, IFirstInterface
    {
        void ISecondInterface.Action()// ЯВНО
        {
            Console.WriteLine("Second interface action");
        }

        void IFirstInterface.Action()// ЯВНО
        {
            Console.WriteLine("First interface action");
        }
    }
```

Синтаксис явной реализации: `void IFirstInterface.Action(){}`

> У этих методов не может быть модификатора `public`
> Это потому что при создании экземпляра класса возникла бы неоднозначность при попытке обратиться к методу с одинаковым названием

Попробуем создать экземпляр и передать его в `Foo` и `Bar`;

```csharp
        static void Main(string[] args)
        {
            MyOtherClass myOtherClass = new MyOtherClass();

            Foo(myOtherClass);
            Bar(myOtherClass);
        }
        static void Foo(IFirstInterface firstInterface)
        {
            firstInterface.Action();
        }
        static void Bar(ISecondInterface secondInterface)
        {
            secondInterface.Action();
        }
    }
```

![[Pasted image 20260215144103.png]]

Эта запись равнозначна с тем, что происходит в при вызове `Foo`:

```csharp
            MyOtherClass myOtherClass = new MyOtherClass();

            IFirstInterface firstInterface = myOtherClass;

            firstInterface.Action();
```

## Почему это одно и то же?

Вот прямое сравнение механизмов:

1. **В первом случае (через метод):**  
    Когда ты вызываешь `Foo(myOtherClass)`, происходит **неявное приведение типа**. Компилятор берет твой объект и «упаковывает» его в ссылку типа `IFirstInterface`, которую требует аргумент метода. Внутри метода `Foo` переменная `firstInterface` — это и есть та самая ссылка.
2. **Во втором случае (вручную):**  
    Ты делаешь это же самое действие, но создаешь локальную переменную `IFirstInterface firstInterface` в коде.

**Технически это одно и то же событие:**  
В обоих вариантах создается **ссылка типа интерфейса**, которая указывает на **тот же самый адрес в памяти**, где лежит объект `myOtherClass`.

Поскольку в твоем классе `Action` реализован **явно**, вызвать его можно **только через интерфейсную ссылку**. Неважно, появилась эта ссылка при передаче в метод или через создание переменной — результат для программы будет идентичным.

# Нужно ли каждый раз выполнять такие действия? Ответ, нет. Нам нужно выполнить приведение типов данных.

Способы:
1) [[73. ОПЕРАТОРЫ AS IS. НАСЛЕДОВАНИЕ И ПРИВЕДЕНИЕ ТИПОВ.]]
2) Явное приведение
3) Неявное


## 1) Пример с `is`
```csharp
MyOtherClass myOtherClass = new MyOtherClass();

if (myOtherClass is IFirstInterface firstInterface)
{
    firstInterface.Action();
}
```
## 1.1) Пример с `as`:
```csharp
MyOtherClass myOtherClass = new MyOtherClass();

IFirstInterface firstInterface = myOtherClass as IFirstInterface;

if (firstInterface != null)
    firstInterface.Action();
```
## 2) Явное приведение:
```csharp
            MyOtherClass myOtherClass = new MyOtherClass();

            ((IFirstInterface)myOtherClass).Action();
```