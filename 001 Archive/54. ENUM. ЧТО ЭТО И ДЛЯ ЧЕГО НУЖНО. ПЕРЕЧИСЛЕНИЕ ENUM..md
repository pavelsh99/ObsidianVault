---
tags:
  - csharp
date: 2025-09-29
---
[54. ENUM. ЧТО ЭТО И ДЛЯ ЧЕГО НУЖНО. ПЕРЕЧИСЛЕНИЕ ENUM.](https://www.youtube.com/watch?v=lBUFlJbNq-Q)
### Что такое enum на примере?

```csharp
while (true)
{
    ConsoleKey key = Console.ReadKey().Key;

    int KeyCode = (int)key
    Console.WriteLine($"\tEnum {key}\t KeyCode = {KeyCode}");

    if (key == ConsoleKey.Enter)
    {
        Console.WriteLine("вы нажади enter!");
    }
}
```



>У каждой клавиши есть свой код и называние, который соответствует целому числу, таким образом можно обратиться к каждой клавише.
>![[Pasted image 20250929170219.png]]

> В этом варианте логика становится абсолютно прозрачной без дополнительных комментариев. `Enum` инкапсулирует «магическое число» `13` под капотом, предоставляя нам понятное имя `ConsoleKey.Enter`.

> когда тут мы приводим `key` к `int`, мы получаем код который соответствует названию на клавиатуре
```csharp
ConsoleKey key = Console.ReadKey().Key;

    int KeyCode = (int)key
    Console.WriteLine($"\tEnum {key}\t KeyCode = {KeyCode}");
```


> таким образом мы получаем такой вывод
![[Pasted image 20250929165716.png]]
### Enum: Синтаксис и Инициализация

> Синтаксис включает ключевое слово `enum`, имя нового типа и фигурные скобки, внутри которых через запятую перечисляются его возможные именованные значения.

```csharp
enum DaysOfWeek
{ 
	Monday,
	Tuesday,
	Wednesday,
	Thursday,
	Friday,
	Saturday,
	Sunday
}
```
##### Нумерация по умолчанию
>Если значения для элементов перечисления не указаны явно, компилятор C# присваивает им целочисленные значения автоматически. **Нумерация по умолчанию начинается с** **0** и увеличивается на единицу для каждого последующего элемента. 

В приведенном выше примере `DayOfWeek`:

• `Monday` будет иметь значение `0`.

• `Tuesday` будет иметь значение `1`

• И так далее, до `Sunday`, которое будет равно `6`.

##### Пользовательская нумерация

>Например, более интуитивно считать **понедельник** первым днем недели, а не нулевым. C# позволяет явно задавать целочисленные значения для элементов `enum`.

```csharp
enum DaysOfWeek
{ 
	Monday = 1,
	Tuesday,
	Wednesday,
	Thursday,
	Friday,
	Saturday,
	Sunday
}
```

>В этом модифицированном примере мы явно присвоили `Monday` значение `1`. Последующие элементы, для которых значение не указано, продолжат нумерацию, инкрементируя значение предыдущего элемента. 

Таким образом:

• `Monday` будет равен `1`.

• `Tuesday` автоматически получит значение `2`.

• `Wednesday` — `3`, и так далее.

>По своей сути, `enum` представляет собой строго типизированный набор именованных целочисленных констант. 
>Он создает новый тип данных, переменные которого могут принимать только одно из перечисленных значений, что ограничивает диапазон допустимых состояний и повышает надежность программы.


### Тип данных значений enum и дефолтные значения.


>Важно понимать, что `enum` — это не просто набор имен, а полноценный тип данных, основанный на одном из целочисленных типов C#. Понимание и управление этим базовым типом критически важно для оптимизации производительности и использования памяти, особенно в системах с ограниченными ресурсами.

>По умолчанию базовым типом данных для любого перечисления является `int` (что эквивалентно `System.Int32`). Это означает, что для хранения значения переменной типа `enum` в памяти выделяется 4 байта.

```csharp
// Определяем базовый тип для нашего enum DayOfWeek
Type underlyingType = Enum.GetUnderlyingType(typeof(DayOfWeek));

// Вывод на консоль покажет "System.Int32"
Console.WriteLine(underlyingType.FullName);
```

>Для оптимизации можно заменить тип данных `enum`'а. 


```csharp
enum DaysOfWeek : byte
{ 
	Monday = 1,
	Tuesday,
	Wednesday,
	Thursday,
	Friday,
	Saturday,
	Sunday
}
```

### Практические Операции с Перечислениями

**От** **enum** **к целочисленному значению:** Чтобы получить числовой код, стоящий за именем элемента, используется явное приведение к целочисленному типу.

```csharp
int dayCode = (int)today; // dayCode будет равен 1
```

**От целочисленного значения к enum:** Обратная операция также выполняется через явное приведение. Это полезно, когда вы получаете числовое значение из внешнего источника (например, из базы данных) и хотите преобразовать его в осмысленный тип `enum`.

```csharp
DayOfWeek someDay = (DayOfWeek)3; // someDay будет равен DayOfWeek.Wednesday
```

####  Использование в Логических Операциях

Рассмотрим пример метода, который возвращает следующий день недели:

```csharp
public DayOfWeek GetNextDay(DayOfWeek day)
{
    if (day < DayOfWeek.Sunday)
    {
        // Если день не последний, просто увеличиваем его на 1
        return day + 1;
    }
    else
    {
        // Если это воскресенье, следующим днем будет понедельник
        return DayOfWeek.Monday;
    }
}
```

В этом коде сравнение `day < DayOfWeek.Sunday` и операция `day + 1` возможны именно потому, что компилятор оперирует базовыми целочисленными значениями (`5 < 7`, `5 + 1` и т.д.).

### Обеспечение Надежности Кода: Валидация и Итерация

Одна из потенциальных проблем при работе с `enum` возникает при получении данных из внешних источников, таких как API, база данных или пользовательский ввод. Если вы получаете число и слепо приводите его к типу `enum`, это может нарушить логику программы и привести к трудноотлавливаемым ошибкам.

Представим, что из-за ошибки в API ваша программа получила число `55` и пытается преобразовать его в `DayOfWeek`.

```csharp
int invalidValue = 55;
DayOfWeek day = (DayOfWeek)invalidValue; // Формально это сработает
```

С точки зрения C#, операция приведения корректна.
Однако переменная `day` теперь содержит невалидное состояние (`55`), для которого в перечислении `DayOfWeek` нет именованного элемента. Если невалидное значение `(DayOfWeek)55` было передано в наш метод `GetNextDay`. Логика `if (day < DayOfWeek.Sunday)` и `return day + 1` поведет себя совершенно непредсказуемо, так как она не была рассчитана на обработку значений вне определенного диапазона.

### Валидация с помощью `.IsDefined`

Для предотвращения подобных ошибок в классе `Enum` существует статический метод `IsDefined`. 
>Его задача — проверить, существует ли в указанном перечислении элемент с заданным  значением. возвращает `true` и `false`


>Он принимает 2 значения:
-  Информация о типе данных `typeof("название enuma")`,принадлежность к которому мы хотим проверить
- Число, которое мы хотим проверить на пренадлежность

Используя `Enum.IsDefined`, можно реализовать безопасное приведение типа:

```csharp
int value = 55; // Значение, полученное извне
DayOfWeek day;

if (Enum.IsDefined(typeof(DayOfWeek), value))
{
    day = (DayOfWeek)value;
}
else
{
    // Обработка ошибки: например, выбросить исключение
    throw new Exception("Получено некорректное значение для дня недели!");
}
```


### Все значения enum

Иногда возникает необходимость получить все возможные значения `enum`

```csharp
enum Color
{
	Red
	Green
	Blue
	Yellow
	Orange
	Black
}
```

>Для этого существует метод `Enum.GetValues`

- Для работы он принимает информацию о типе данных `typeof("назв. enum")`
```csharp
var allValues = Enum.GetValues(typeof(Color));

// или так или так
Array allColors = Enum.GetValues(typeof(Color));
```

> После выполнения этого метода мы получаем массив, со всеми значениями

```Csharp
// Перебираем и выводим все значения
foreach (Color color in allColors)
{
    Console.WriteLine(color);
}
```

## Парсинг `enum`'ов

>Энамы можно парсить 
>Мы можем строкой написать н-р день недели и превратить его в объект `enum`
![[Pasted image 20251006125551.png]]
```csharp

 enum DayOfWeek : byte
{
    Sunday = 1,
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
}

string str = Console.ReadLine();
DayOfWeek day = (DayOfWeek)Enum.Parse(typeof(DayOfWeek), str, ignoreCase: true);
Console.WriteLine(color);

```
![[Pasted image 20251006125755.png]]

> Так же есть и метод `Enum.TryParse()`
> ![[Pasted image 20251006130116.png]]

### Примеры работы с enum

- Создание объекта типа enum и присваивание значения
```csharp
DayOfWeek dayOfWeek = DayOfWeek.Monday;

Console.WriteLine(dayOfWeek);//Вывод:Monday
```

- Получение типа данных
```csharp
Console.WriteLine(Enum.GetUnderlyingType(typeof(DayOfWeek)));
```

- Приведение к `int`
```csharp
Console.WriteLine (int(dayOfWeek));// Вывод 1 (потому что Monday = 1)
```

-  Приведение `int` к `DayOfWeek`
```csharp
Console.WriteLine((DayOfWeek)3); // Получим Wednesday
```

-  Получаем следующий день
```csharp
DayOfWeek nextDay = GetNextDay(dayOfWeek);
Console.WriteLine(nextDay);

static DayOfWeek GetNextDay(DayOfWeek day)
{
	if (day<DayOfWeek.Sunday)
		return day + 1;
	
	return DayOfWeek.Monday
}
```

### `enum` и`switch` полезная фича

>Можно очень быстро и удобно генерировать и разветвлять код при помощи `switch`

>если набрать `swtich`, нажать 2 раза `TAB` то сгенерируется код:

```csharp
            switch (switch_on)
            {
                default:
            }
```

>Потом вставляем в условие `switch` объект `enum`
```csharp
            switch (day)
            {
                default:
            }
```

>Кликаем мышкой в любом месте:

```csharp
            switch (day)
            {
                case DayOfWeek.Sunday:
                    break;
                case DayOfWeek.Monday:
                    break;
                case DayOfWeek.Tuesday:
                    break;
                case DayOfWeek.Wednesday:
                    break;
                case DayOfWeek.Thursday:
                    break;
                case DayOfWeek.Friday:
                    break;
                case DayOfWeek.Saturday:
                    break;
                default:
                    break;
            }
```

> Получаем удобный код.