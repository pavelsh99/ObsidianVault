---
tags:
  - csharp
  - ООП
  - структуры
date: 2026-02-17
---
[Структуры в C# | структуры и классы отличия | struct vs class | C# ОТ НОВИЧКА К ПРОФЕССИОНАЛУ | # 81](https://www.youtube.com/watch?v=8E9P_lnJ7RI)

# СТРУКТУРА VS. КЛАСС:

```csharp
    public class ClassPoint
    {
        public int X { get; set; }
        public int Y { get; set; }

        public void Print()
        {
            Console.WriteLine($"X:{0},Y:{1}", X , Y);
        }
    }
    public struct StructPoint
    {
        public int X { get; set; }
        public int Y { get; set; }

        public void Print()
        {
            Console.WriteLine($"X:{0},Y:{1}", X, Y);
        }
    }
```

## Отличия:

- `Class` - ссылочный тип (хранятся в Heap)
- `Struct` - значимый тип (хранятся в стеке)

- Скорость выполнения кода в структуре гораздо быстрее
- Удаляется структура тоже быстрее, не нужно ждать сборщик мусора.

## СТРУКТУРА VS. КЛАСС(при работе с методами)

```csharp
        static void Foo(StructPoint structPoint)
        {
            structPoint.X++;
            structPoint.Y++;
        }
        static void Bar(ClassPoint classPoint)
        {
            classPoint.X++;
            classPoint.Y++;
        }
        static void Main(string[] args)
        {
            ClassPoint classPoint = new ClassPoint();
            StructPoint structPoint = new StructPoint();
            Foo(structPoint);
            Bar(classPoint);
        }
```

Есть 2 метода: 
- 1 принимает структуру и увеличивает параметр ее свойств
- 2й принимает объект класса и увеличивает его свойства

Результат:
![[Pasted image 20260218133056.png]]

Почему структура не поменяла своих свойств в отличие от класса?
Ответ:
Структура-
•	Создается копия структуры в памяти
•	Метод Foo(StructPoint) изменяет копию, а не оригинал
•	Изменения теряются после выхода из метода
Класс-
•	Передается ссылка (адрес) в памяти на объект
•	Метод Bar(ClassPoint) изменяет оригинальный объект
•	Изменения сохраняются

> При наличии большого количества полей/свойств в методы структура будет медленнее. 

> Это потому что чтобы передать каждое поле данные копируются, что занимает больше времени, чем передача данных по ссылке как в методе.

> Проблему быстродействия в этом случае можно решить, если передавать структуру по ссылке через `ref` или `in`

[[43. КЛЮЧЕВОЕ СЛОВО REF]], [[45. МОДИФИКАТОР IN. РАЗНИЦА между IN REF и OUT.]]

Сравнение быстродействия структуры, класса и  структуры с `in`
![[Pasted image 20260218134135.png]]

## Структура и наследование и полиморфизм:

> При использовании структур невозможно наследование и полиморфизм
> Соответственно `virtual`, `override` нет, как и `protected` перед свойствами
    [[75. ПОЛИМОРФИЗМ. ВИРТУАЛЬНЫЕ МЕТОДЫ. VIRTUAL OVERRIDE.]]

> Но можно использовать интерфейсы

У них нет деструктора(финалайзера), метода, который вызывается, когда класс уничтожается сборщиком мусора.

Отличается поведение конструктора без параметров. 

#вопрос_на_собеседовании Как будет работать метод `Equals`

![[Pasted image 20260218134952.png]]
В случае с классом ответ `false`, а со структурой - `true`

Сравнение классов выдает `false`, тк создаются 2 разных объекта в управляемой куче по ссылке.

В случае со структурами, они сравниваются не по ссылке а по данным в полях

# Когда нам лучше использовать структуру:

- Когда нам не нужно использовать полиморфизм и наследование
- Когда в объекте структура должно быть немного простых типов данных
- Если же их много можно использовать `in/ref`.
- Структура по сути это что-то чуть сложнее чем `int, bool`
