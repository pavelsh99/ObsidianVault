---
tags:
  - csharp
  - наследование
  - ООП
date: 2025-12-09
---
[Наследование в C# и модификаторы доступа | модификатор protected c# | C# ООП | # 74](https://www.youtube.com/watch?v=MDcPcKltm9M&list=PLQOaTSbfxUtD6kMmAYc8Fooqya3pjLs1N&index=94)
# Модификаторы доступа в CSHARP

```csharp
class A
{
	public int publicField;
	private int privateInt;
	protected int protectedInt;
}
```

В сишарп модификаторы доступа могут относиться как к классам так и к их полям, свойствам и методам и другим компонентам класса.

Так же они могут комбинироваться сами с собой

```csharp
private protected int protectedInt;
```

# Сравниваем модификаторы `private`, `public` и `protected`

## На уровне класса

```csharp
        public A()
        {
            Console.WriteLine($"{publicField}");//поле доступно
            Console.WriteLine($"{privateField}");//поле доступно
            Console.WriteLine($"{protectedField}");//поле доступно
        }
        public void Foo()
        {
            Console.WriteLine($"{publicField}");//поле доступно
            Console.WriteLine($"{privateField}");//поле доступно
            Console.WriteLine($"{protectedField}");//поле доступно
        }
```

Внутри класса у нас есть доступ ко всем полям `private`, `public` и `protected`
при использовании например внутри метода или конструктора.

## На уровне объекта класса

![[Pasted image 20251210000650.png]]

На уровне объекта у нас доступно только `public` поле.

> `private` и `protected` на уровне одного класса не отличаются:
> внутри доступны, а на уровне объекта класса - нет

## Если мы используем #наследование 

Унаследуем от класса `class A{}` класс `class B{}`

```csharp
    class B : A
    {
        B()
        {
	        
        }
    }
```

Класс наследник имеет доступ ко всему функционалу базового, но к чему он будет иметь доступ, зависит от модификаторов.

### Модификатор `public`:

```csharp
    class B : A
    {
        B()
        {
            Console.WriteLine($"{publicField}");
        }
    }
```

модификатор `public` означает что доступ к полю есть всегда и везде.

### Модификатор `private`:

![[Pasted image 20251210002044.png]]

Наследник *напрямую* не имеет доступа к полю `private`. Но опосредованно может.

> Но это не значит что поля в наследнике нет. Оно всё равно создается потому, что при создании наследника создается предок. 
> [[72. КЛЮЧЕВОЕ СЛОВО BASE. НАСЛЕДОВАНИЕ И КОНСТРУКТОР КЛАССА.]]

#### Когда наследник имеет доступ к `private` полю базового класса:

Внутри базового класса `class A`  у нас есть `public` метод `Foo()`, который использует `private` поле.

```csharp
    class A
    {
        public void Foo()
        {
            Console.WriteLine($"{publicField}");
            Console.WriteLine($"{privateField}");//ТУТ
            Console.WriteLine($"{protectedField}");
        }
    }
```

Т.к он `public`, то мы можем к нему обратиться даже на уровне объекта класса наследника:
![[Pasted image 20251210004605.png]]

Еще, мы можем вызывать этот метод`Foo()`, внутри класса наследника, в конструкторе или в другом методе:

![[Pasted image 20251210004832.png]]
### Модификатор `protected`:

![[Pasted image 20251210002700.png]]

Поле `protected` доступно при наследовании, но не доступно на уровне экземпляра класса

| Тип элемента класса/<br>Уровень обращения | `public` | `private`                    | `protected` |
| ----------------------------------------- | -------- | ---------------------------- | ----------- |
| Доступно внутри класса                    | Да       | Да                           | Да          |
| Доступно в объекте класса                 | Да       | Нет                          | Нет         |
| Доступно при наследовании                 | Да       | Нет, но в особом случае - Да | Да          |


## `Модификаторы`  доступа и объект класса наследника

![[Pasted image 20251210003825.png]]

Тут та же ситуация, как и на уровне объекта базового класса:
	`public` доступно
    `private` недоступно
    `protected` недоступно
